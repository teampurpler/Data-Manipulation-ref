# -*- coding: utf-8 -*-
"""â€œData Manipulation in Python I

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1a9rPYIbVOtb0eYUNoMSzqDoQ4x4WKm2u

# Data Manipulation in Python I

**Objectives**
* Learn Colaboratory fundanmental operations
* Learn and Review Python Basics
* Learn Numpy Basics

**Things need to know**

##Introduction to [Colaboratory](https://colab.research.google.com/notebooks/welcome.ipynb#scrollTo=-Rh3-Vt9Nev9) 
* Install Colaboratory (check *class doc*)
* Install and import python packages
"""

#@title import packages
import numpy as np #numpy
import pandas as pd #pandas

#@title install packages
!pip install pandasql

"""## Python Basics

### **Numeric Types**
"""

x = 2 # =>2
print(type(x)) # class 'int'

y = 1.5 # =>1.5
print(type(y)) # class 'float'

# Math
x = x ** 3 # =>8 exponential
print(x) 

x += 1 # =>9 addition x = x + 1
print(x)

x %= 2 # =>1 modulo
print(x)

x += y # =>2.5
print(x)

"""### **Boolean**"""

t = True
f = False

print(type(t)) # class 'bool' 
print(t or f) # True
print(t and f) # False 
print(not t) # False
print(not f) # True

print(1 or False) # (Advanced, just know it is enough, is it really important?)

"""### **String**

Strings are immutable type, which means we can't change the value once initialized.
"""

# Construct string
s1 = 'single quote' # use single quotes
print(type(s1)) # class 'str'

s2= "double quote" # use double quotes 
print(type(s2)) # class 'str'

# String concatenation
s3 = s1 + ' and ' + s2 # string concatenation
print(s3)

# String useful functions
print('Caplitalize the string: ' + s3.capitalize()) # Caplitalize the string 
print('Uppercase the string: ' + s3.upper()) # Uppercase the string
print('\'o\' occurrences: ' + str(s3.count('o'))) # Count the occurrences of a character
print('first \'te\' index: ' + str(s3.index('te'))) # The lowest index of the occurrence

print(s3[1]) # string indexing

# (Advanced)Tripe Quotes
s = '''
You can specify multi-line string.
This is an example.
'''

print(s)

# (Advanced)String format
# escape {{}}
# https://docs.python.org/3/library/string.html#formatstrings
s = "{} is handsome, but {} is not"
print(s.format('Rayman','Jason'))

s = "{1} is handsome, but {0} is not, {2} is super handsome"
print(s.format('Jason', 'Rayman', 'Mike'))

s = "{name1} is handsome, but {name2} is not"
print(s.format(name2 = 1, name1 = 'Rayman'))

"""### **List**


List is mutable type

"""

lst1 = [] # initialize an empty list
print(type(lst1)) # class 'list'

lst2 = [1, 2, 3, 4] # create a list with same data type values
print(lst2)

lst3 = ['one', 2, 'three', 4] # create a list with different data type values
print(lst3)

lst2.append(5) # append a new element to end of the list
print(lst2)

lst2.pop(3) # remove the 4th element of the list
print(lst2)

lst2[2] = 100 # list is mutable
print(lst2)

print(lst2[0]) # list indexing
print(lst2[-1]) # negative index, access from end of list
print(len(lst2)) # the length of list
print(lst2 + lst3) # list concatenation

"""**Slicing**"""

lst = range(6) # create an list of numbers using built-in function range
print(type(lst)) # class 'range'

lst = list(lst) # change to list
print(type(lst)) # class 'list'

# [start(inclusive) : end(exclusive) : step]

print(lst) # [0, 1, 2, 3, 4, 5]
print(lst[0:6]) # index from 0 to 5, [0, 1, 2, 3, 4, 5]
print(lst[1:]) # index from 1 to the end, [1, 2, 3, 4, 5]
print(lst[:4]) # index from start to 4, [0, 1, 2, 3]
print(lst[:]) # the whole list, [0, 1, 2, 3, 4, 5]
print(lst[:-1]) # negative index slicing, [0, 1, 2, 3, 4]
print(lst[-1:]) # negative index slicing, [5]
print(lst[::2]) # change index step to 2, [0, 2, 4]
print(lst[::-1]) # reverse order, [5, 4, 3, 2, 1, 0], common usage

lst[2:4] = [3, 2] # modify the values by slicing
print(lst) # [0, 1, 3, 2, 4, 5]

a = np.array([[1,2,3],[4,5,6]])

print(a[0:2][1])

b = a[0:2,1]
b.shape

a[0:2][1]

lst = range(6) # create an list of numbers using built-in function range
print(type(lst)) # class 'range'

lst = list(lst) # change to list
print(type(lst)) # class 'list'

print(lst)
print(lst[:-1]) # negative index slicing, [0, 1, 2, 3, 4]
print(lst[-1:]) # negative index slicing, [5]

print(lst[0:7]) # index from 0 to 5, [0, 1, 2, 3, 4, 5]

ss = 'Hello World!' # initialize a string
print(ss)

print(ss[:]) # the whole list
print(ss[1:3]) # index from 1 to 2

"""### **Tuple**

A tuple is an (immutable) ordered list of values. A tuple is in many ways similar to a list; one of the most important differences is that tuples can be used as keys in dictionaries and as elements of sets, while lists cannot.
"""

t = (21, 42) # create a tuple
print(type(t))

"""

### **Dictionary**

{key: value} 

key-value pairs"""

skills = ['ML', 'Stat', 'Coding', 'Business']
scores = [90, 80, 1, 59]

print(scores[skills.index('Coding')])

score_dict = {'ML': 90, 'Stat': 80, 'Coding': 1, 'Business': 59} # create a dictionary
print(score_dict['ML']) # get ML score
print('Stat' in score_dict) # check if 'Stat' in the dictionary

score_dict['Spark'] = 70 # Add a new key-value pair to the dictionary
print(score_dict['Spark'])

print("current score:" + str(score_dict['Coding']))
score_dict['Coding'] = 100 # Modify the existing value in the dictionary
print("afterwards: " + str(score_dict['Coding']))

score_dict.pop('Spark')

"""### **Set**

A set is an unordered collection of *distinct* elements. 
"""

skills = {'ML', 'Stat', 'Coding', 'Business'}
skills_list = ['ML', 'Stat', 'Coding', 'Business']

print('Business' in skills) # check if an element is in a set
print('Spark' in skills_list) # False

skills.add('Spark') # add an element
print(skills)
skills.remove('Spark') # remove an element
print(skills)

"""## Numpy

NumPy is the fundamental package for scientific computing in Python. It is a Python library that provides a multidimensional array object, various derived objects (such as masked arrays and matrices), and an assortment of routines for fast operations on arrays.

At the core of the NumPy package, is the ndarray object. This encapsulates n-dimensional arrays of homogeneous data types, with many operations being performed in compiled code for performance.

**Arrays**
"""

lst = [[1, 2, 3], [4, 5, 6]] # 2x3
a = np.array(lst) # create array from lists
print(type(a)) # class 'numpy.ndarray'
print(a)
print(a[0]) # first row
print(a[0][1]) # first row, second column
print(a.shape) # 2 x 3
print(a.ndim) # 2 dimensions
print(a.dtype) # data type of the elements of array
print(a.size) # total number of elements in the matrix

# useful functions to create numpy array
b = np.arange(0, 10, 2, dtype='float') # create 1d array, [start, stop)
print(type(b)) # class 'numpy.ndarray'
print(b)
print(b.shape)

c = np.linspace(1.5, 2.5, 9) # create 1d array with float, [start, stop]
print(type(c)) # class 'numpy.ndarray'
print(c)
print(c.shape)

d = np.zeros((2, 3)) # all zeros
print(type(d)) # class 'numpy.ndarray'
print(d)

e = np.ones((2, 3)) # all ones
print(type(e)) # class 'numpy.ndarray'
print(e)

f = np.full((2, 3), 9) # constant matrix
print(type(f)) # class 'numpy.ndarray'
print(f)

g = np.eye(3) # 3 x 3 identity matrix
print(type(g)) # class 'numpy.ndarray'
print(g)

d = np.zeros((2, 3)) # all zeros
print(type(d)) # class 'numpy.ndarray'
print(d)
print(d.dtype)

j = d.reshape((3, 2, 1))
print(j)
print(j.shape)
print(j.dtype)

# reshape
h = b.reshape((5, 1))
print(h)

# One shape dimension can be -1. 
# In this case, the value is inferred from the length of the array and remaining dimensions.
i = c.reshape((3, -1))
print(i)
print(i.shape)

"""**Indexing and Slicing**"""

a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])

# Use slicing to pull out the subarray consisting of the first 2 rows
# and columns 1 and 2; b is the following array of shape (2, 2):
# [[2 3]
#  [6 7]]
b = a[:2, 1:3]
print(b)
print(a[1]) # access a row
print(a[:, 1:2]) # access a col
print(a[1, 1]) # access single value

a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])

# (Advanced)Two ways of accessing the data in the middle row of the array.
# Mixing integer indexing with slices yields an array of lower rank,
# while using only slices yields an array of the same rank as the
# original array:
r1 = a[0, :] # rank 1 view of the first row
r2 = a[0:1, :] # rank 2 view of the first row 
print(r1, r1.shape)
print(r2, r2.shape)

num_col = r1.shape[0]
r1 = r1.reshape(-1, num_col)
print(r1, r1.shape)

# boolean masking
import numpy as np

a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])

a_idx1 = (a < 5) # return the boolean array that satisfies the conidtion
print(a_idx1)
a_idx2 = (a >=5) & (a <= 10) # return the boolean array that satisfies the conidtion
print(a_idx2)

print(a[a_idx1]) # return the corresponding array
print(a[a_idx2]) # return the corresponding array

print(a[(a > 5) & (a < 10)]) # single statement

"""**Math**"""

import numpy as np

a = np.array([[10, 11, 12], [13, 14, 15]])
print(a.shape)
print(a)
b = np.arange(1, 7).reshape((2, 3))
print(b.shape)
print(b)

# element-wise calculation:
print(a + b)
print(a - b)
print(np.add(a, b))
print(a * b)

# Matrix product
print(np.dot(a, b.transpose())) # 2x3, 3x2
print(a.T.dot(b)) # 3x2, 2x3

# Matrix multiplication
#print(a, a.shape)
#print(b, b.shape)
# axb dot b*c -> axc
# 2x3 dot 3x4 -> 2x4
# 3x2 dot 2x3 -> 3x3
print(a.T, a.T.shape)
print(b, b.shape)

print(a.T.dot(b))

# calculation along row or column index, calculate by the index of the axis which is set
# Axis 0 will act on all the ROWS in each COLUMN
# Axis 1 will act on all the COLUMNS in each ROW
# check this link for axis https://stackoverflow.com/questions/22149584/what-does-axis-in-pandas-mean
# https://stackoverflow.com/questions/25773245/ambiguity-in-pandas-dataframe-numpy-array-axis-definition
print(np.sum(a, axis = 0)) # the column is fixed, act along row for this column
print(np.sum(a, axis = 1)) # the row    is fixed, act along column for this row

"""**Broadcasting**

Read more for [broadcasting](https://docs.scipy.org/doc/numpy-1.15.0/user/basics.broadcasting.html)
"""

# (Advanced+)broadcasting

import numpy as np

a = np.array([[10, 11, 12], [13, 14, 15]]) # 2x3
print(a)

a += 1 # add 1 to all the elements # 1
print(a)

a += np.array([-1, -2, -3]) # add [-1, -2, -3] to all columns for each row # 3
print(a)

a += np.array([[-1], [-2]]) # add [[-1], [-2]] to all rows for each column 2x1
print(a)

"""**Random**"""

# generate random number
print(np.random.rand(2,2)) # Random numbers between [0,1) of shape 2,2
print(np.random.randn(2,2)) # Normal distribution with mean=0 and variance=1 of shape 2,2
print(np.random.randint(0, 10, size=[2,2])) # Random integers between [0, 10) of shape 2,2
print(np.random.random()) # One random number between [0,1)
print(np.random.random(size=[2,2])) # Random numbers between [0,1) of shape 2,2
print(np.random.choice(['a', 'e', 'i', 'o', 'u'], size=10)) # Pick 10 items from a given list, with equal probability
print(np.random.choice(['a', 'e', 'i', 'o', 'u'], size=10, p=[0.3, 0.1, 0.1, 0.4, 0.1])) # Pick 10 items from a given list with a predefined probability 'p'
print(np.random.choice(np.arange(100), size=[10,3], replace=True)) # get 10x3 random samples from [0-99] with replacement

#(Advanced) use random generator to do train/test split

url="https://gist.githubusercontent.com/curran/a08a1080b88344b0c8a7/raw/d546eaee765268bf2f487608c537c05e22e4b221/iris.csv"
iris = pd.read_csv(url)
print(iris.head())
print(iris.info())

# Split data into training and testing
iris_idx = np.arange(iris.shape[0])

num_training = int(np.floor(0.75 * iris.shape[0]))
iris_train_idx = np.random.choice(iris_idx, size=num_training, replace=False)
iris_test_idx = np.delete(iris_idx, iris_train_idx)
iris_train = iris.iloc[iris_train_idx]
iris_test = iris.iloc[iris_test_idx]

print(iris_train.info())
print(iris_test.info())

# (Advanced)use np.random.shuffle
iris_idx = np.arange(iris.shape[0])
np.random.shuffle(iris_idx)
iris.index = iris_idx
num_training = int(np.floor(0.75 * iris.shape[0]))
iris_train = iris.iloc[:num_training]
iris_test = iris.iloc[num_training:]

print(iris_train.info())
print(iris_test.info())

# (Advanced)use sklearn to spilt data
from sklearn.model_selection import train_test_split

X = iris.drop('species', axis = 1)
y = iris['species']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25)

print(X_train.info())

# (Advanced) A random seed (random_state)
# random.seed() is a number (or vector) used to initialize a pseudorandom number generator.
# generate the deterministic random data 
np.random.seed(2)

np.random.random()

np.random.random()